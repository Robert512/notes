{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"java.html":{"url":"java.html","title":"Java","keywords":"","body":"计算机网络 HTTP： https://mp.weixin.qq.com/s/cfa1f8NR6hs42I5FYCkl6A JDK基础 面试精选109-StringBuilder是线程不安全的 JVM 面试精选107-Java内存区域（运行时数据区域）和内存模型（JMM） 设计模式 代理模式 并发 ThreadLocal 线程池 数据库 mysql 面试精选-Mysql知识点 面试精选112-B+树 缓存 Redis 面试精选110-Redis分布式锁如何解决锁超时问题 "},"Java8.html":{"url":"Java8.html","title":"Java8","keywords":"","body":"Lambda 能够使用Lambda的依据是必须有相应的函数接口； lambda不是匿名内部类的缩写，与匿名内部类不同，lambda表达式被封装成了主类的一个私有方法，并通过invokedynamic指令进行调用，因此Lambda内部的this引用也就跟内部类对象没什么关系了； 回顾Java集合框架的接口继承结构： 接口名 Java8新加入的方法 Collection（5） removeIf() spliterator() stream() parallelStream() forEach() List（2） replaceAll() sort() Map（10） getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge() 函数接口 接口 入参 出参 说明 Predicate T boolean 断言 Consumer T / 消费一个数据 Function T R 输入T输出R函数 Supplier / T 提供一个数据 UnaryOperator T T 一元函数（输入输出类型相同） BiFunction (T,U) R 2个输入函数 BinaryOperator (T,T) T 二元函数 方法引用、构造器引用、数组引用 方法引用类别 举例 引用静态方法 Integer::sum 引用某个对象的方法 list::add 引用某个类的方法 String::length 引用构造方法 HashMap::new 方法引用： 若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用（可以将方法引用理解为 Lambda 表达式的另外一种表现形式） 对象的引用 :: 实例方法名 类名 :: 静态方法名 类名 :: 实例方法名 注意： ①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！ ②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName 构造器引用 : 构造器的参数列表，需要与函数式接口中参数列表保持一致！ 类名 :: new 数组引用 类型[] :: new; 类型推断 Lambda 表达式中的参数类型都是由编译器推断 得出的。Lambda 表达式中无需指定类型，程序依然可 以编译，这是因为 javac 根据程序的上下文，在后台 推断出了参数的类型。Lambda 表达式的类型依赖于上 下文环境，是由编译器推断出来的。 Comparator com = (Integer x,Integer y) -> { //Integer 类型可以省略 System.out.println(\"函数式接口\"); return Integer.compare(x, y); }; BinaryOperator add = (Long x, Long y) -> x + y;// 4 BinaryOperator addImplicit = (x, y) -> x + y;// 5 类型推断 变量引用 内部类里面引用外部的变量的时候，必须是final。因为传的都是值到方法参数当中。 public class Test { public static void main(String[] args) { User user = new User(18); changeUser(user); System.out.println(user); } private static void changeUser(User user) { user.setAge(19); // 能修改user的age } private static void changeUserToNull(User user) { user = null; // 不能修改 } } 级联表达式和柯里化 就是嵌套多层Function Function>> currying = x -> y -> z -> (x+y)*z; System.out.println(currying.apply(4).apply(5).apply(6)); //54 Stream stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如： 调用Collection.stream()或者Collection.parallelStream()方法 调用Arrays.stream(T[] array)方法 常见的stream接口继承关系如图： stream和collections有以下不同： 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations) 中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。 结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。 创建 相关方法 集合 Collection.stream/parallelStream 数组 Arrays.stream 数字Stream IntStream/LongStream.range/rangeClosed Random.ints/longs/doubles 自己创建 Stream.generate/iterate 中间操作 相关方法 无状态操作 map/mapToXxx flagMap/flagMapToXxx filter peek unordered 有状态操作 distinct sorted limit/skip 终止操作 相关方法 非短路操作 forEach/forEachOrdered collect/toArray reduce min/max/count 短路操作 findFirst/findAny allMatch/anyMatch/noneMatch 并行流 多次调用 parallel / sequential, 以最后一次调用为准. // 多次调用 parallel / sequential, 以最后一次调用为准. IntStream.range(1, 100) // 调用parallel产生并行流 .parallel().peek(StreamDemo5::debug) // 调用sequential 产生串行流 .sequential().peek(StreamDemo5::debug2) .count(); 并行流使用的线程池修改和自定义 // 并行流使用的线程池: ForkJoinPool.commonPool // 默认的线程数是 当前机器的cpu个数 // 使用这个属性可以修改默认的线程数 System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"20\"); IntStream.range(1, 100).parallel().peek(StreamDemo5::debug).count(); // 使用自己的线程池, 不使用默认线程池, 防止任务被阻塞 // 线程名字 : ForkJoinPool-1 ForkJoinPool pool = new ForkJoinPool(20); pool.submit(() -> IntStream.range(1, 100).parallel() .peek(StreamDemo5::debug).count()); pool.shutdown(); 收集器 收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西： 目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。 新元素如何添加到容器中？是List.add()还是Map.put()。 如果并行的进行规约，还需要告诉collect() 3. 多个部分结果如何合并成一个。 //　将Stream规约成List Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); List list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);// 方式１ //List list = stream.collect(Collectors.toList());// 方式2 System.out.println(list); reduce()擅长的是生成一个值 collect()擅长生成一个集合或者Map等复杂的对象 使用collect()生成Collection // 将Stream转换成List或Set Stream stream = Stream.of(\"I\", \"love\", \"you\", \"too\"); List list = stream.collect(Collectors.toList()); // (1) Set set = stream.collect(Collectors.toSet()); // (2) 使用collect()生成Map 使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。 使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。 使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。 使用collect()做字符串join // 使用Collectors.joining()拼接字符串 Stream stream = Stream.of(\"I\", \"love\", \"you\"); //String joined = stream.collect(Collectors.joining());// \"Iloveyou\" //String joined = stream.collect(Collectors.joining(\",\"));// \"I,love,you\" String joined = stream.collect(Collectors.joining(\",\", \"{\", \"}\"));// \"{I,love,you}\" collect()自定义 除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)方法，收集任何形式你想要的信息。不过Collectors工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。 运行机制 Optional Optional类（java.util.Optional）是一个容器类，代表一个值存在或者不存在，原来用null表示一个值不存在，现在Optional可以更好表达这个概念，并且可以避免空指针异常。 常用方法： Optional.of(T t)：创建一个Optional实例 Optional.empty()：创建一个空的Optional实例 Optional.ofNullable(T t)：若t不为null，创建Optional实例，否则创建空实例 isPresent()：判断是否包含值 orElse(T t)：如果调用对象包含值，返回该值，否则返回t orElseGet(Supplier s)：如果调用对象包含值，返回该值，否则返回s获取的值 map(Function f)：如果油脂对其处理，并且返回处理后的Optional，否则返回Optional.empty() flatMap(Fucntion mapper)：与map类似，要求返回值必须是Optional 时间 Reference 学习指南 后端进阶-Lambda "},"Spring注解驱动开发.html":{"url":"Spring注解驱动开发.html","title":"Spring注解驱动开发","keywords":"","body":" IOC容器 注入方式 传统 定义xml public class MainTest { public static void main(String[] args) { ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Person person = (Person) classPathXmlApplicationContext.getBean(\"person\"); System.out.println(person); } } 包扫描 注解 @Configuration public class MainConfig { @Bean public Person person() { return new Person(\"jack\", 11); } } AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); Person bean = applicationContext.getBean(Person.class); System.out.println(bean); String[] beanNamesForType = applicationContext.getBeanNamesForType(Person.class); for (String beanName : beanNamesForType) { System.out.println(beanName); } 包扫描 @ComponentScans( value = { @ComponentScan(value=\"com.atguigu\",includeFilters = { /* @Filter(type=FilterType.ANNOTATION,classes={Controller.class}), @Filter(type=FilterType.ASSIGNABLE_TYPE,classes={BookService.class}),*/ @Filter(type=FilterType.CUSTOM,classes={MyTypeFilter.class}) },useDefaultFilters = false) } ) 自定义filter public class MyTypeFilter implements TypeFilter { /** * metadataReader：读取到的当前正在扫描的类的信息 * metadataReaderFactory:可以获取到其他任何类信息的 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { // TODO Auto-generated method stub //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类的路径） Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println(\"--->\"+className); if(className.contains(\"er\")){ return true; } return false; } } @Scope prototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。 每次获取的时候才会调用方法创建对象； singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。 以后每次获取就是直接从容器（map.get()）中拿 request：同一次请求创建一个实例 session：同一个session创建一个实例 @Lazy @Conditional //类中组件统一设置。满足当前条件，这个类中配置的所有bean注册才能生效； @Conditional({WindowsCondition.class}) @Configuration //判断是否linux系统 public class LinuxCondition implements Condition { /** * ConditionContext：判断条件能使用的上下文（环境） * AnnotatedTypeMetadata：注释信息 */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { // TODO是否linux系统 //1、能获取到ioc使用的beanfactory ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); //2、获取类加载器 ClassLoader classLoader = context.getClassLoader(); //3、获取当前环境信息 Environment environment = context.getEnvironment(); //4、获取到bean定义的注册类 BeanDefinitionRegistry registry = context.getRegistry(); String property = environment.getProperty(\"os.name\"); //可以判断容器中的bean注册情况，也可以给容器中注册bean boolean definition = registry.containsBeanDefinition(\"person\"); if(property.contains(\"linux\")){ return true; } return false; } } 给容器中注入组件 给容器中注册组件； 1）、包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类] 2）、@Bean[导入的第三方包里面的组件] 3）、@Import[快速给容器中导入一个组件] 1）、@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名 2）、ImportSelector:返回需要导入的组件的全类名数组； 3）、ImportBeanDefinitionRegistrar:手动注册bean到容器中 4）、使用Spring提供的 FactoryBean（工厂Bean）; 1）、默认获取到的是工厂bean调用getObject创建的对象 2）、要获取工厂Bean本身，我们需要给id前面加一个& &colorFactoryBean Bean生命周期 bean的生命周期： bean创建---初始化----销毁的过程 容器管理bean的生命周期； 我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法 构造（对象创建） 单实例：在容器启动的时候创建对象 多实例：在每次获取的时候创建对象\\ BeanPostProcessor.postProcessBeforeInitialization 初始化： 对象创建完成，并赋值好，调用初始化方法。。。 BeanPostProcessor.postProcessAfterInitialization 销毁： 单实例：容器关闭的时候 多实例：容器不会管理这个bean；容器不会调用销毁方法； 遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization， 一但返回null，跳出for循环，不会执行后面的 BeanPostProcessor.postProcessorsBeforeInitialization BeanPostProcessor原理 populateBean(beanName, mbd, instanceWrapper); （构造器）给bean进行属性赋值 initializeBean { applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化 applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } 1）、指定初始化和销毁方法； 通过@Bean指定init-method和destroy-method； 2）、通过让Bean实现InitializingBean（定义初始化逻辑）， DisposableBean（定义销毁逻辑）; 3）、可以使用JSR250； @PostConstruct：在bean创建完成并且属性赋值完成；来执行初始化方法 @PreDestroy：在容器销毁bean之前通知我们进行清理工作 4）、BeanPostProcessor【interface】：bean的后置处理器； 在bean初始化前后进行一些处理工作； postProcessBeforeInitialization:在初始化之前工作 postProcessAfterInitialization:在初始化之后工作 Spring底层对 BeanPostProcessor 的使用； bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,xxx BeanPostProcessor; 执行顺序： 生成beanDefination -> 构造器 -> 属性赋值 -> postProcessBeforeInitialization ->自定义初始化方法（init-method -> InitializingBean -> @PostConstruct） ->postProcessAfterInitialization 开始内置的 postProcessBeforeInitialization 属性赋值 - @Value //使用@Value赋值； 1、基本数值 2、可以写SpEL； #{} 3、可以写${}；取出配置文件【properties】中的值（在运行环境变量里面的值） 4、 ConfigurableEnvironment environment = applicationContext.getEnvironment(); String property = environment.getProperty(\"person.nickName\"); //使用@PropertySource读取外部配置文件中的k/v保存到运行的环境变量中;加载完外部的配置文件以后使用${}取出配置文件的值 @PropertySource(value={\"classpath:/person.properties\"}) 自动装配(AutoWired Profile) AutoWired 自动装配; Spring利用依赖注入（DI），完成对IOC容器中中各个组件的依赖关系赋值； 1）、@Autowired：自动注入： 1）、默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值 2）、如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找 applicationContext.getBean(\"bookDao\") 3）、@Qualifier(\"bookDao\")：使用@Qualifier指定需要装配的组件的id，而不是使用属性名 4）、自动装配默认一定要将属性赋值好，没有就会报错； 可以使用@Autowired(required=false); 5）、@Primary：让Spring进行自动装配的时候，默认使用首选的bean； 也可以继续使用@Qualifier指定需要装配的bean的名字 BookService{ @Autowired BookDao bookDao; } 2）、Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解] @Resource: 可以和@Autowired一样实现自动装配功能；默认是按照组件名称进行装配的； 没有能支持@Primary功能没有支持@Autowired（reqiured=false）; @Inject: 需要导入javax.inject的包，和Autowired的功能一样。没有required=false的功能； @Autowired:Spring定义的； @Resource、@Inject都是java规范 AutowiredAnnotationBeanPostProcessor:解析完成自动装配功能； 3）、 @Autowired:构造器，参数，方法，属性；都是从容器中获取参数组件的值 1）、[标注在方法位置]：@Bean+方法参数；参数从容器中获取;默认不写@Autowired效果是一样的；都能自动装配 2）、[标在构造器上]：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取 3）、放在参数位置： 4）、自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory，xxx）； 自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件；Aware； 把Spring底层一些组件注入到自定义的Bean中； xxxAware：功能使用xxxProcessor； ApplicationContextAware==》ApplicationContextAwareProcessor； Profile Profile： Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能； 开发环境、测试环境、生产环境； 数据源：(/A)(/B)(/C)； @Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件 1）、加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境 2）、写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效 3）、没有标注环境标识的bean在，任何环境下都是加载的； //1、使用命令行动态参数: 在虚拟机参数位置加载 -Dspring.profiles.active=test //2、代码的方式激活某种环境； AOP AOP：【动态代理】 指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式； 1、导入aop模块；Spring AOP：(spring-aspects) 2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx） 3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行； 通知方法： - 前置通知(@Before)：logStart：在目标方法(div)运行之前运行 - 后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束） - 返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行 - 异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行 - 环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()） 4、给切面类的目标方法标注何时何地运行（通知注解）； 5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中; 6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect) [7]、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】 在Spring中很多的 @EnableXXX; 三步： 1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect） 2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式） 3）、开启基于注解的aop模式；@EnableAspectJAutoProxy * 1）、将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect） * 2）、在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式） * 3）、开启基于注解的aop模式；@EnableAspectJAutoProxy AOP原理 AOP原理：【看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么？】 @EnableAspectJAutoProxy； 1、@EnableAspectJAutoProxy是什么？ ​ @Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar ​ 利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion ​ internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator ​ 给容器中注册一个AnnotationAwareAspectJAutoProxyCreator； 2、 AnnotationAwareAspectJAutoProxyCreator： AnnotationAwareAspectJAutoProxyCreator ​ ->AspectJAwareAdvisorAutoProxyCreator ​ ->AbstractAdvisorAutoProxyCreator ​ ->AbstractAutoProxyCreator ​ implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware ​ 关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory AbstractAutoProxyCreator.setBeanFactory() AbstractAutoProxyCreator.有后置处理器的逻辑； AbstractAdvisorAutoProxyCreator.setBeanFactory() -> initBeanFactory() AnnotationAwareAspectJAutoProxyCreator.initBeanFactory() AOP流程 1、传入配置类，创建ioc容器 2、注册配置类，调用refresh（）刷新容器； 3、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建； 1）、先获取ioc容器已经定义了的 需要创建对象的所有BeanPostProcessor 2）、给容器中加别的BeanPostProcessor 3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor； 4）、再给容器中注册实现了Ordered接口的BeanPostProcessor； 5）、注册没实现优先级接口的BeanPostProcessor； 6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中； 创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】 1）、创建Bean的实例 2）、populateBean；给bean的各种属性赋值 3）、initializeBean：初始化bean； 1）、invokeAwareMethods()：处理Aware接口的方法回调 2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（） 3）、invokeInitMethods()；执行自定义的初始化方法 4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）； 4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder 7）、把BeanPostProcessor注册到BeanFactory中； beanFactory.addBeanPostProcessor(postProcessor); =======以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程======== AnnotationAwareAspectJAutoProxyCreator => InstantiationAwareBeanPostProcessor 4）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean 1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName); getBean->doGetBean()->getSingleton()-> 2）、创建bean 【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()】 1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建； 只要创建好的Bean都会被缓存起来 2）、createBean（）;创建bean； AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例 【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】 【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】 1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation 希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续 1）、后置处理器先尝试返回对象； bean = applyBeanPostProcessorsBeforeInstantiation（）： 拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor; 就执行postProcessBeforeInstantiation if (bean != null) { bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); } 2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和3.6流程一样； 3）、 AnnotationAwareAspectJAutoProxyCreator AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】 的作用： 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()； 关心MathCalculator和LogAspect的创建 1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean） 2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean， 或者是否是切面（@Aspect） 3）、是否需要跳过 1）、获取候选的增强器（切面里面的通知方法）【List candidateAdvisors】 每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor； 判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true 2）、永远返回false 2）、创建对象 postProcessAfterInitialization； return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下 1）、获取当前bean的所有增强器（通知方法） Object[] specificInterceptors 1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的） 2、获取到能在bean使用的增强器。 3、给增强器排序 2）、保存当前bean在advisedBeans中； 3）、如果当前bean需要增强，创建当前bean的代理对象； 1）、获取所有增强器（通知方法） 2）、保存到proxyFactory 3）、创建代理对象：Spring自动决定 JdkDynamicAopProxy(config);jdk动态代理； ObjenesisCglibAopProxy(config);cglib的动态代理； 4）、给容器中返回当前组件使用cglib增强了的代理对象； 5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程； 3）、目标方法执行 ； 容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）； 1）、CglibAopProxy.intercept();拦截目标方法的执行 2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链； List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 1）、List interceptorList保存所有拦截器 5 一个默认的ExposeInvocationInterceptor 和 4个增强器； 2）、遍历所有的增强器，将其转为Interceptor； registry.getInterceptors(advisor); 3）、将增强器转为List； 如果是MethodInterceptor，直接加入到集合中 如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor； 转换完成返回MethodInterceptor数组； 3）、如果没有拦截器链，直接执行目标方法; 拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制） 4）、如果有拦截器链，把需要执行的目标对象，目标方法， 拦截器链等信息传入创建一个 CglibMethodInvocation 对象， 并调用 Object retVal = mi.proceed(); 5）、拦截器链的触发过程; 1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法； 2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行； 拦截器链的机制，保证通知方法与目标方法的执行顺序； 总结 1、 @EnableAspectJAutoProxy 开启AOP功能 2、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator 3、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器； 4、容器的创建流程： ​ 1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象 ​ 2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean ​ 1）、创建业务逻辑组件和切面组件 ​ 2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程 ​ 3）、组件创建完之后，判断组件是否需要增强 ​ 是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）； 5、执行目标方法： 1）、代理对象执行目标方法 2）、CglibAopProxy.intercept()； 1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor） 2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行； 3）、效果： 正常执行：前置通知-》目标方法-》后置通知-》返回通知 出现异常：前置通知-》目标方法-》后置通知-》异常通知 扩展原理 扩展原理： BeanPostProcessor：bean后置处理器，bean创建对象初始化前后进行拦截工作的 1、BeanFactoryPostProcessor：beanFactory的后置处理器； 在BeanFactory标准初始化之后调用，来定制和修改BeanFactory的内容； 所有的bean定义已经保存加载到beanFactory，但是bean的实例还未创建 BeanFactoryPostProcessor原理: 1)、ioc容器创建对象 2)、invokeBeanFactoryPostProcessors(beanFactory); 如何找到所有的BeanFactoryPostProcessor并执行他们的方法； 1）、直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法 2）、在初始化创建其他组件前面执行 2、BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor postProcessBeanDefinitionRegistry(); 在所有bean定义信息将要被加载，bean实例还未创建的； 优先于BeanFactoryPostProcessor执行； 利用BeanDefinitionRegistryPostProcessor给容器中再额外添加一些组件； 原理： 1）、ioc创建对象 2）、refresh()-》invokeBeanFactoryPostProcessors(beanFactory); 3）、从容器中获取到所有的BeanDefinitionRegistryPostProcessor组件。 1、依次触发所有的postProcessBeanDefinitionRegistry()方法 2、再来触发postProcessBeanFactory()方法BeanFactoryPostProcessor； 4）、再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessBeanFactory()方法 3、ApplicationListener：监听容器中发布的事件。事件驱动模型开发； public interface ApplicationListener 监听 ApplicationEvent 及其下面的子事件； 步骤： 1）、写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类） @EventListener; 原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener； 2）、把监听器加入到容器； 3）、只要容器中有相关事件的发布，我们就能监听到这个事件； ContextRefreshedEvent：容器刷新完成（所有bean都完全创建）会发布这个事件； ContextClosedEvent：关闭容器会发布这个事件； 4）、发布一个事件： applicationContext.publishEvent()； 原理： ContextRefreshedEvent、IOCTest_Ext$1[source=我发布的时间]、ContextClosedEvent； 1）、ContextRefreshedEvent事件： 1）、容器创建对象：refresh()； 2）、finishRefresh();容器刷新完成会发布ContextRefreshedEvent事件 2）、自己发布事件； 3）、容器关闭会发布ContextClosedEvent； 【事件发布流程】： 3）、publishEvent(new ContextRefreshedEvent(this)); 1）、获取事件的多播器（派发器）：getApplicationEventMulticaster() 2）、multicastEvent派发事件： 3）、获取到所有的ApplicationListener； for (final ApplicationListener listener : getApplicationListeners(event, type)) { 1）、如果有Executor，可以支持使用Executor进行异步派发； Executor executor = getTaskExecutor(); 2）、否则，同步的方式直接执行listener方法；invokeListener(listener, event); 拿到listener回调onApplicationEvent方法； 【事件多播器（派发器）】 1）、容器创建对象：refresh(); 2）、initApplicationEventMulticaster();初始化ApplicationEventMulticaster； 1）、先去容器中找有没有id=“applicationEventMulticaster”的组件； 2）、如果没有this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); 并且加入到容器中，我们就可以在其他组件要派发事件，自动注入这个applicationEventMulticaster； 【容器中有哪些监听器】 1）、容器创建对象：refresh(); 2）、registerListeners(); 从容器中拿到所有的监听器，把他们注册到applicationEventMulticaster中； String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); //将listener注册到ApplicationEventMulticaster中 getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); SmartInitializingSingleton 原理：->afterSingletonsInstantiated(); 1）、ioc容器创建对象并refresh()； 2）、finishBeanFactoryInitialization(beanFactory);初始化剩下的单实例bean； 1）、先创建所有的单实例bean；getBean(); 2）、获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的； 如果是就调用afterSingletonsInstantiated(); Spring容器创建过程 prepareRefresh 刷新前的准备工作 obtainFreshBeanFactory 获取子类刷新后内部的BeanFactory实例 prepareBeanfactory 为容器注册必要的系统级别bean postProcessBeanFactory 允许容器的子类去注册postProcessor inovkeBeanFactoryProcessor 调用容器注册的容器级别的后置处理器 registerBeanPostProcessors 向容器注册Bean级别的后置处理器 initMessageSource 初始化国际化配置 initApplicationEventMulticaster 初始化事件发布者组件 onRefresh 在单例Bean初始化之前预留给子类初始化其他特殊的bean的口子 registerListeners 向前面的事件发布者组件注册事件监听者 finishBeanFactoryInitialization 设置系统级别的服务，实例化所有非懒加载的单例 finishRefresh 触发初始化完成的回调方法，并发布容器刷新完成的事件给监听者 resetCommonCaches 重置Spring内核中的共用缓存 Spring容器的refresh()【创建刷新】; 1、prepareRefresh()刷新前的预处理; 1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法； 2）、getEnvironment().validateRequiredProperties();检验属性的合法等 3）、earlyApplicationEvents= new LinkedHashSet();保存容器中的一些早期的事件； 2、obtainFreshBeanFactory();获取BeanFactory； 1）、refreshBeanFactory();刷新【创建】BeanFactory； 创建了一个this.beanFactory = new DefaultListableBeanFactory(); 设置id； 2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象； 3）、将创建的BeanFactory【DefaultListableBeanFactory】返回； 3、prepareBeanFactory(beanFactory);BeanFactory的预准备工作（BeanFactory进行一些设置）； 1）、设置BeanFactory的类加载器、支持表达式解析器... 2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】 3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx； 4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入： BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext 5）、添加BeanPostProcessor【ApplicationListenerDetector】 6）、添加编译时的AspectJ； 7）、给BeanFactory中注册一些能用的组件； environment【ConfigurableEnvironment】、 systemProperties【Map】、 systemEnvironment【Map】 4、postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作； 1）、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置 ======================以上是BeanFactory的创建及预准备工作================================== 5、invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor的方法； BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的； 两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 1）、执行BeanFactoryPostProcessor的方法； 先执行BeanDefinitionRegistryPostProcessor 1）、获取所有的BeanDefinitionRegistryPostProcessor； 2）、看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、 postProcessor.postProcessBeanDefinitionRegistry(registry) 3）、在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor； postProcessor.postProcessBeanDefinitionRegistry(registry) 4）、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors； postProcessor.postProcessBeanDefinitionRegistry(registry) 再执行BeanFactoryPostProcessor的方法 1）、获取所有的BeanFactoryPostProcessor 2）、看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、 postProcessor.postProcessBeanFactory() 3）、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor； postProcessor.postProcessBeanFactory() 4）、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor； postProcessor.postProcessBeanFactory() 6、registerBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）【 intercept bean creation】 不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的 BeanPostProcessor、 DestructionAwareBeanPostProcessor、 InstantiationAwareBeanPostProcessor、 SmartInstantiationAwareBeanPostProcessor、 MergedBeanDefinitionPostProcessor【internalPostProcessors】、 1）、获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级 2）、先注册PriorityOrdered优先级接口的BeanPostProcessor； 把每一个BeanPostProcessor；添加到BeanFactory中 beanFactory.addBeanPostProcessor(postProcessor); 3）、再注册Ordered接口的 4）、最后注册没有实现任何优先级接口的 5）、最终注册MergedBeanDefinitionPostProcessor； 6）、注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是 applicationContext.addApplicationListener((ApplicationListener) bean); 7、initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）； 1）、获取BeanFactory 2）、看容器中是否有id为messageSource的，类型是MessageSource的组件 如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource； MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取； 3）、把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource； beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource); MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale); 8、initApplicationEventMulticaster();初始化事件派发器； 1）、获取BeanFactory 2）、从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster； 3）、如果上一步没有配置；创建一个SimpleApplicationEventMulticaster 4）、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入 9、onRefresh();留给子容器（子类） 1、子类重写这个方法，在容器刷新的时候可以自定义逻辑； 10、registerListeners();给容器中将所有项目里面的ApplicationListener注册进来； 1、从容器中拿到所有的ApplicationListener 2、将每个监听器添加到事件派发器中； getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); 3、派发之前步骤产生的事件； 11、finishBeanFactoryInitialization(beanFactory);初始化所有剩下的单实例bean； 1、beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean 1）、获取容器中的所有Bean，依次进行初始化和创建对象 2）、获取Bean的定义信息；RootBeanDefinition 3）、Bean不是抽象的，是单实例的，是懒加载； 1）、判断是否是FactoryBean；是否是实现FactoryBean接口的Bean； 2）、不是工厂Bean。利用getBean(beanName);创建对象 0、getBean(beanName)； ioc.getBean(); 1、doGetBean(name, null, null, false); 2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来） 从private final Map singletonObjects = new ConcurrentHashMap(256);获取的 3、缓存中获取不到，开始Bean的创建对象流程； 4、标记当前bean已经被创建 5、获取Bean的定义信息； 6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】 7、启动单实例Bean的创建流程； 1）、createBean(beanName, mbd, args); 2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象； 【InstantiationAwareBeanPostProcessor】：提前执行； 先触发：postProcessBeforeInstantiation()； 如果有返回值：触发postProcessAfterInitialization()； 3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4） 4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args); 利用工厂方法或者对象的构造器创建出Bean实例； 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); 调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName); 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper); 赋值之前： 1）、拿到InstantiationAwareBeanPostProcessor后置处理器； postProcessAfterInstantiation()； 2）、拿到InstantiationAwareBeanPostProcessor后置处理器； postProcessPropertyValues()； =====赋值之前：=== 3）、应用Bean属性的值；为属性利用setter方法等进行赋值； applyPropertyValues(beanName, mbd, bw, pvs); 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd); 1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法 BeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware 2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); BeanPostProcessor.postProcessBeforeInitialization（）; 3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd); 1）、是否是InitializingBean接口的实现；执行接口规定的初始化； 2）、是否自定义初始化方法； 4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization BeanPostProcessor.postProcessAfterInitialization()； 5）、注册Bean的销毁方法； 5）、将创建的Bean添加到缓存中singletonObjects； ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。； 所有Bean都利用getBean创建完成以后； 检查所有的Bean是否是SmartInitializingSingleton接口的；如果是；就执行afterSingletonsInstantiated()； 12、finishRefresh();完成BeanFactory的初始化创建工作；IOC容器就创建完成； 1）、initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor 默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有new DefaultLifecycleProcessor(); 加入到容器； 写一个LifecycleProcessor的实现类，可以在BeanFactory void onRefresh(); void onClose(); 2）、 getLifecycleProcessor().onRefresh(); 拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()； 3）、publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件； 4）、liveBeansView.registerApplicationContext(this); ======总结=========== 1）、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息； 1）、xml注册bean； 2）、注解注册Bean；@Service、@Component、@Bean、xxx 2）、Spring容器会合适的时机创建这些Bean 1）、用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中； 2）、统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()； 3）、后置处理器；BeanPostProcessor 1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能； AutowiredAnnotationBeanPostProcessor:处理自动注入 AnnotationAwareAspectJAutoProxyCreator:来做AOP功能； xxx.... 增强的功能注解： AsyncAnnotationBeanPostProcessor .... 4）、事件驱动模型； ApplicationListener；事件监听； ApplicationEventMulticaster；事件派发： ​ ​ web servlet3.0 异步请求 "},"SpringSource.html":{"url":"SpringSource.html","title":"Spring源码","keywords":"","body":"Spring源码 refresh流程分析 prepareRefresh 刷新前的准备工作 obtainFreshBeanFactory 获取子类刷新后内部的BeanFactory实例 prepareBeanfactory 为容器注册必要的系统级别bean postProcessBeanFactory 允许容器的子类去注册postProcessor inovkeBeanFactoryProcessor 调用容器注册的容器级别的后置处理器 registerBeanPostProcessors 向容器注册Bean级别的后置处理器 initMessageSource 初始化国际化配置 initApplicationEventMulticaster 初始化事件发布者组件 onRefresh 在单例Bean初始化之前预留给子类初始化其他特殊的bean的口子 registerListeners 向前面的事件发布者组件注册事件监听者 finishBeanFactoryInitialization 设置系统级别的服务，实例化所有非懒加载的单例 finishRefresh 触发初始化完成的回调方法，并发布容器刷新完成的事件给监听者 resetCommonCaches 重置Spring内核中的共用缓存 Spring容器的refresh()【创建刷新】; 1、prepareRefresh()刷新前的预处理; 1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法； 2）、getEnvironment().validateRequiredProperties();检验属性的合法等 3）、earlyApplicationEvents= new LinkedHashSet();保存容器中的一些早期的事件； 2、obtainFreshBeanFactory();获取BeanFactory； 1）、refreshBeanFactory();刷新【创建】BeanFactory； 创建了一个this.beanFactory = new DefaultListableBeanFactory(); 设置id； 2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象； 3）、将创建的BeanFactory【DefaultListableBeanFactory】返回； 3、prepareBeanFactory(beanFactory);BeanFactory的预准备工作（BeanFactory进行一些设置）； 1）、设置BeanFactory的类加载器、支持表达式解析器... 2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】 3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx； 4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入： BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext 5）、添加BeanPostProcessor【ApplicationListenerDetector】 6）、添加编译时的AspectJ； 7）、给BeanFactory中注册一些能用的组件； environment【ConfigurableEnvironment】、 systemProperties【Map】、 systemEnvironment【Map】 4、postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作； 1）、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置 ======================以上是BeanFactory的创建及预准备工作================================== 5、invokeBeanFactoryPostProcessors(beanFactory);执行BeanFactoryPostProcessor的方法； BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的； 两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 1）、执行BeanFactoryPostProcessor的方法； 先执行BeanDefinitionRegistryPostProcessor 1）、获取所有的BeanDefinitionRegistryPostProcessor； 2）、看先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、 postProcessor.postProcessBeanDefinitionRegistry(registry) 3）、在执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor； postProcessor.postProcessBeanDefinitionRegistry(registry) 4）、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors； postProcessor.postProcessBeanDefinitionRegistry(registry) 再执行BeanFactoryPostProcessor的方法 1）、获取所有的BeanFactoryPostProcessor 2）、看先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、 postProcessor.postProcessBeanFactory() 3）、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor； postProcessor.postProcessBeanFactory() 4）、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor； postProcessor.postProcessBeanFactory() 6、registerBeanPostProcessors(beanFactory);注册BeanPostProcessor（Bean的后置处理器）【 intercept bean creation】 不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的 BeanPostProcessor、 DestructionAwareBeanPostProcessor、 InstantiationAwareBeanPostProcessor、 SmartInstantiationAwareBeanPostProcessor、 MergedBeanDefinitionPostProcessor【internalPostProcessors】、 1）、获取所有的 BeanPostProcessor;后置处理器都默认可以通过PriorityOrdered、Ordered接口来执行优先级 2）、先注册PriorityOrdered优先级接口的BeanPostProcessor； 把每一个BeanPostProcessor；添加到BeanFactory中 beanFactory.addBeanPostProcessor(postProcessor); 3）、再注册Ordered接口的 4）、最后注册没有实现任何优先级接口的 5）、最终注册MergedBeanDefinitionPostProcessor； 6）、注册一个ApplicationListenerDetector；来在Bean创建完成后检查是否是ApplicationListener，如果是 applicationContext.addApplicationListener((ApplicationListener) bean); 7、initMessageSource();初始化MessageSource组件（做国际化功能；消息绑定，消息解析）； 1）、获取BeanFactory 2）、看容器中是否有id为messageSource的，类型是MessageSource的组件 如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource； MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取； 3）、把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource； beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource); MessageSource.getMessage(String code, Object[] args, String defaultMessage, Locale locale); 8、initApplicationEventMulticaster();初始化事件派发器； 1）、获取BeanFactory 2）、从BeanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster； 3）、如果上一步没有配置；创建一个SimpleApplicationEventMulticaster 4）、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入 9、onRefresh();留给子容器（子类） 1、子类重写这个方法，在容器刷新的时候可以自定义逻辑； 10、registerListeners();给容器中将所有项目里面的ApplicationListener注册进来； 1、从容器中拿到所有的ApplicationListener 2、将每个监听器添加到事件派发器中； getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); 3、派发之前步骤产生的事件； 11、finishBeanFactoryInitialization(beanFactory);初始化所有剩下的单实例bean； 1、beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean 1）、获取容器中的所有Bean，依次进行初始化和创建对象 2）、获取Bean的定义信息；RootBeanDefinition 3）、Bean不是抽象的，是单实例的，是懒加载； 1）、判断是否是FactoryBean；是否是实现FactoryBean接口的Bean； 2）、不是工厂Bean。利用getBean(beanName);创建对象 0、getBean(beanName)； ioc.getBean(); 1、doGetBean(name, null, null, false); 2、先获取缓存中保存的单实例Bean。如果能获取到说明这个Bean之前被创建过（所有创建过的单实例Bean都会被缓存起来） 从private final Map singletonObjects = new ConcurrentHashMap(256);获取的 3、缓存中获取不到，开始Bean的创建对象流程； 4、标记当前bean已经被创建 5、获取Bean的定义信息； 6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】 7、启动单实例Bean的创建流程； 1）、createBean(beanName, mbd, args); 2）、Object bean = resolveBeforeInstantiation(beanName, mbdToUse);让BeanPostProcessor先拦截返回代理对象； 【InstantiationAwareBeanPostProcessor】：提前执行； 先触发：postProcessBeforeInstantiation()； 如果有返回值：触发postProcessAfterInitialization()； 3）、如果前面的InstantiationAwareBeanPostProcessor没有返回代理对象；调用4） 4）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args); 利用工厂方法或者对象的构造器创建出Bean实例； 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); 调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName); 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper); 赋值之前： 1）、拿到InstantiationAwareBeanPostProcessor后置处理器； postProcessAfterInstantiation()； 2）、拿到InstantiationAwareBeanPostProcessor后置处理器； postProcessPropertyValues()； =====赋值之前：=== 3）、应用Bean属性的值；为属性利用setter方法等进行赋值； applyPropertyValues(beanName, mbd, bw, pvs); 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd); 1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);执行xxxAware接口的方法 BeanNameAware\\BeanClassLoaderAware\\BeanFactoryAware 2）、【执行后置处理器初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); BeanPostProcessor.postProcessBeforeInitialization（）; 3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd); 1）、是否是InitializingBean接口的实现；执行接口规定的初始化； 2）、是否自定义初始化方法； 4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization BeanPostProcessor.postProcessAfterInitialization()； 5）、注册Bean的销毁方法； 5）、将创建的Bean添加到缓存中singletonObjects； ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。； 所有Bean都利用getBean创建完成以后； 检查所有的Bean是否是SmartInitializingSingleton接口的；如果是；就执行afterSingletonsInstantiated()； 12、finishRefresh();完成BeanFactory的初始化创建工作；IOC容器就创建完成； 1）、initLifecycleProcessor();初始化和生命周期有关的后置处理器；LifecycleProcessor 默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】；如果没有new DefaultLifecycleProcessor(); 加入到容器； 写一个LifecycleProcessor的实现类，可以在BeanFactory void onRefresh(); void onClose(); 2）、 getLifecycleProcessor().onRefresh(); 拿到前面定义的生命周期处理器（BeanFactory）；回调onRefresh()； 3）、publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件； 4）、liveBeansView.registerApplicationContext(this); ======总结=========== 1）、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息； 1）、xml注册bean； 2）、注解注册Bean；@Service、@Component、@Bean、xxx 2）、Spring容器会合适的时机创建这些Bean 1）、用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中； 2）、统一创建剩下所有的bean的时候；finishBeanFactoryInitialization()； 3）、后置处理器；BeanPostProcessor 1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能； AutowiredAnnotationBeanPostProcessor:处理自动注入 AnnotationAwareAspectJAutoProxyCreator:来做AOP功能； xxx.... 增强的功能注解： AsyncAnnotationBeanPostProcessor .... 4）、事件驱动模型； ApplicationListener；事件监听； ApplicationEventMulticaster；事件派发： 参考 Java葵花宝典 Spring-资源加载 Spring-解析xml Spring-自定义wsd "},"RPC实战与核心原理.html":{"url":"RPC实战与核心原理.html","title":"RPC","keywords":"","body":"基础 核心原理 什么是RPC Remote Procedure Call，远程过程调用，主要作用有 屏蔽远程过程调用与本地调用的区别，让我们感觉就是调用项目内的方法； 隐藏底层网络通信的复杂性，让我们更专注业务逻辑。 通信流程原理 应用架构图 思考问题 调用过程超时了怎么处理业务？ 什么场景下适合使用RPC？ 什么时候需要考虑压缩？ 协议 设计可扩展且向后兼容的协议 协议的作用 ​ 数据传输只能通过二进制形式在网络中拆包传输，需要通过协议”断句“，分割出正确的数据。 有了HTTP协议，为什么还设计RPC私有协议 RPC更多负责应用间调用，需要性能更高； HTTP协议属于无状态协议，客户端无法对请求和响应进行关联 可扩展的RPC协议 通过设计扩展字段，向后兼容 序列化 调用方请求的输入参数都是对象，需要通过序列化反序列化技术将对象与二进制做转换。 常用的序列化技术 JDK原生序列化：存在安全漏洞 JSON：传输的数据要相对较小，否则影响性能 Hessian：使用上更加方便，在对象兼容性上更好 Protobuf：更高效，更通用 序列化技术选型 优先考虑：安全性、通用型、兼容性 其次考虑：性能、效率、空间开销 使用RPC框架注意事项 出入参体积尽量不要太大 尽量使用常用的、原生的对象，尤其是集合类 对象要尽量简单，没有太多依赖关系，没有复杂的继承关系 网络通信 一次RPC调用，本质就是服务消费者与服务提供者之间的一次网络信息交换的过程。 所谓两台PC机之间的网络通信，实际上是两台PC机对网络IO的操作。 常见网络IO模型 同步阻塞IO 同步非阻塞IO IO多路复用 异步非阻塞IO 其中同步阻塞IO和IO多路复用比较常用。 IO多路复用是指多个网络连接的IO可以注册到一个复用器（select）上，当用户进程调用了select，那么整个进程会被阻塞。同时，内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核中拷贝到用户进程。 网络IO模型的选型 需要系统内核的支持和编程语言的支持。 RPC框架在网络通信上更倾向于IO多路复用。 零拷贝（Zero-copy） 传统网络IO读写流程 这里可以看到，每一次应用程序的完整读写操作，都需要在用户空间和内核空间中来回拷贝，并且每一次拷贝，都需要CPU进行一次（系统内核与用户进程间）的上下文切换，浪费了CPU和性能。 零拷贝（操作系统） 虚拟内存的存在，避免了用户空间和内核空间的拷贝切换。 零拷贝两种方式，mmap+write方式和sendfile方式。 Netty框架中的零拷贝是在用户空间的拷贝（拆包粘包），Netty中有很多ChannelHandler实现类，都是通过CompositeByteBuf、slice、warp操作来处理TCP传输中的拆包和粘包问题的。 动态代理 主要作用是面向接口编程，屏蔽RPC处理流程 常见代理方式 JDK默认代理:被代理类只能是接口，JDK8对反射调用有了很大提升 Javassist：生成字节码，不需要反射调用，但是会冻结CtClass对象 Byte Buddy：后起之秀，Spring、Jackson都用到，可读性更高、执行速度更快 PRC实战 剖析RPC源码，动手实现RPC 源码地址：https://github.com/grpc/grpc-java 进阶 架构设计 RPC架构 协议模块 传输模块：为了屏蔽网络传输的复杂性而封装的单独的数据传输模块 协议封装：序列化和反序列化、“断句“ 数据压缩 可扩展架构 包括核心功能体系和插件体系，可扩展性好，实现开闭原则，用户可以非常方便的通过插件扩展来实现自己的功能，不需要修改核心功能本身；其次保持了核心包的精简，依赖外部包少，有效减少版本冲突问题。 服务发现 为什么需要服务发现 为了高何用，在生成环境中服务提供方都是以集群的方式对外提供服务，集群里面的这些IP可能随时变化，需要一本“通讯录”及时获取到对应服务节点，这个获取过程就是服务发现。 服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心，注册中心将这个服务节点的IP和接口保存下来。 服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的IP，然后缓存到本地，并用于后续的远程调用。 为什么不使用DNS DNS流程图 为了提升性能和减少DNS服务压力，DNS采取了多级缓存机制，一般配置的缓存时间比较长，特别是JVM默认缓存是永久有效的，所以说服务调用者不能及时感知服务节点的变化。 一种方案是加负载均衡设备。将域名绑定到这台负载均衡的设备上，通过DNS拿到负载均衡的IP。这样服务调用的时候，调用方直接跟VIP建立连接，由VIP机器完成TCP转发。 但是这种方案也有问题： 搭建负载均衡设备或者TCP/IP四层代理，需要额外成本； 请求流量都经过网络传输，多经过一次网络传输，会额外浪费些性能； 负载均衡节点或者摘除节点，一般需要手动添加，当大批量扩容或者下线时，会有大量的人工操作和生效延迟 基于Zookeeper的服务发现 搭建一个Zookeeper集群作为注册中心集群，服务注册的时候只需要服务节点向Zookeeper节点写入注册信息极客，利用Zookeeper的Watcher机制完成服务的订阅和服务下发功能。 但是Zookeeper本身性能问题，当连接到Zookeeper的节点数量特别多，对Zookeeper读写特别频繁，且Zookeeper存储的目录达到一定数量的时候，Zookeeper将不再稳定，CPU持续升高，最终宕机。宕机之后，由于各业务的节点还在持续发送读写请求，刚一启动，Zookeeper就因无法承受瞬间的读写压力，马上宕机。 基于消息总线的最终一致性的注册中心 消息总线机制牺牲掉Zookeeper的CP，选择AP，换取整个注册中心集群的性能和稳定性。 为了性能，采用两级缓存，注册中心和消费者的内存缓存，通过异步推拉模式来确保最终一致性。 健康检查 健康监测能够帮助我们从连接列表里面过滤掉一些存在问题的节点，避免在发请求的时候选择出有问题的节点而影响业务。但是在设计健康监测方案的时候，我们不能简单从TCP连接是否健康、心跳是否正常等简单维度考虑，因为健康监测的目的是保证”业务无损“，所以可以加入业务请求可用率因素，最大化地提升RPC接口可用率。 路由策略 上线涉及到变更，为了减少风险会采用灰度发布，同时会采用路由策略让某些指定的应用才能调用新上线的应用做测试。 在注册中心做路由策略的话，复杂的计算逻辑会让注册中心压力很大，因此一般会把这个路由规则下发到服务调用方，如下图： 参数路由：更细粒度的路由方式，比如商品ID，每次关于该商品的请求都可以降落到新应用或者老应用上。如下图： 负载均衡 负载均衡主要分为软负载和硬负载，软负载就是在一台或多台服务器上安装负载均衡软件，如LVS、Nginx等，硬负载就是通过硬件设备来实现负载均衡，如F5服务器等。负载均衡算法包括随机法、轮询法、最小连接法等。 RPC框架的负载均衡与Web的负载均衡不同之处在于：RPC框架不依赖一个负载均衡或者负载均衡服务器来实现负载均衡的，而是由RPC框架本身实现的，服务调用者自主选择服务节点，发起服务调用。 这样好处在于，RPC框架不在需要依赖专门的负载均衡设备，可以节约成本；减少了与负载均衡设备间的额外网络传输，提升了传输效率；并且负载均衡策略可配，便于服务治理。 RPC自适应负载均衡 异常重试 当我们发起一次RPC调用，希望它尽可能成功的时候，就需要异常重试，比如通过用户名密码验证，获取用户基本信息。 异常重试需要考虑的问题： 业务逻辑必须幂等； 超时时间可以重置； 去掉有问题的节点； 添加异常白名单，对异常判定，决定是否重试。 RPC异常重试 优雅关闭 服务下线存在问题：服务提供方正在关闭，还没有从健康列表中移除，导致调用失败。 处理策略： 人肉方式通知调用方去删除健康列表的节点，但是运维成本太高； 注册中心方式，但是服务发现保证最终一致性，不能保证实时性； 服务提供方内存维护一份调用方连接集合，主动调用方，在关闭前设置“挡板”。 优雅启动 应用启动的时候会处于高负载状态，导致调用方过来的请求可能出现大面积超时，使业务受损。 启动预热 让刚启动的服务提供方应用不承担全部流量，而是让它被调用的次数随时间移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。 延迟暴露 服务启动，有可能还没加载完就把RPC的bean服务注册到注册中心了。因此我们可以先让应用启动完成，预留一个Hook过程，让用户扩展实现模拟调用（让JVM指令能够预热起来），之后在发布到注册中心。 熔断限流 服务端通过限流进行自我保护，服务端的限流阈值配置都是作用于单机的，如果需要对整个服务设置限流阈值，可以在注册中心或者配置中心下发限流阈值，让RPC框架自己去计算，也可以依赖一个专门的限流服务，但是性能和耗时上有劣势。还有可以通过降级等方案。 调用端可以通过熔断机制进行自我保护，防止调用下游服务出现异常，或者耗时过长影响调用端的业务逻辑，RPC框架可以在动态代理的逻辑上去整合熔断器，实现RPC的熔断功能。 业务分组 熔断限流对业务还是有损的，通过流量隔离可以最大限度保障业务无损。如下图 分组带来一个直接问题是影响高可用，可以通过“借道”方式配置次分组。 高级 异步RPC 异步调用可以压榨单机吞吐量，因为向服务端发送请求与接收服务端发送过来的响应消息是完全独立的，可以让RPC框架提供一种回调方式，让业务逻辑异步处理，处理完之后调用RPC框架的回调接口，将最终的结果通过回调方式响应给调用端。 实现方案可以使用Java8原生支持的ComplableFuture 安全问题 服务提供方将jar发布到私服上，所有的应用都可以通过这个jar坐标调用，带来一定的隐患。 HMAC（不可逆加密算法）是一种实现，服务提供方应用里放一个用于HMAC签名的私钥，在授权平台上用这个私钥为申请调用的调用方应用进行签名，这个签名生成的串就变成了调用方唯一的身份。服务提供方在收到调用方的授权请求之后，只需要验证下这个签名跟调用方应用信息是否一致即可。 问题定位 借助合理的分装异常信息 借助分布式链路跟踪 时钟轮 假设调用端1s内发送了1万次请求，这1万次请求都是5s后超时，这是扫描的线程在这5s内会不停的重复扫描，很浪费CPU资源，这是可以采用时钟轮，将请求超时的定时任务放到时钟轮的槽当中。 注意点： 时钟槽位的单位越短，时间轮触发任务的时间就越精确； 时钟轮的槽位越多，那么一个任务被重复扫描的概率越小，因为只有在多重时钟轮中的任务才会被重复扫描。 使用场景：调用端超时处理；调用端与服务端启动超时；定时心跳 流量回放 新应用改造后重新测试的成本高，结果也不一定可靠。已知线上流量比手动维护的TestCase的场景更加丰富，可以记录线上的请求和返回，对新改造的应用进行“流量回放”，即用对应的请求去调用，再与预期结果对比。 泛化调用 有时候调用方并不知道服务提供方的接口API，如 场景一 场景二 这时，可以采用泛化调用方式 "}}